#include <iostream>       // Для ввода-вывода (cin, cout)
#include <string>         // Для работы со строками (string)
#include <stack>          // Для использования стека (stack)
#include <cmath>          // Для математических функций (не используется здесь, но может пригодиться)
#include <iomanip>        // Для форматирования вывода (setprecision, fixed)

using namespace std;      // Чтобы не писать std:: перед каждой стандартной функцией

// Функция для определения приоритета операторов
int priory(char op) {
    if (op == '+' || op == '-') return 1;  // Сложение и вычитание имеют низкий приоритет
    if (op == '*' || op == '/') return 2;  // Умножение и деление имеют высокий приоритет
    return 0;  // Для скобок и других символов - самый низкий приоритет
}

// Функция для выполнения математической операции
double gm(double a, double b, char op) {
    switch (op) {         // Проверяем какой оператор нужно применить
    case '+': return a + b;  // Если плюс - складываем числа
    case '-': return a - b;  // Если минус - вычитаем второе число из первого
    case '*': return a * b;  // Если умножить - перемножаем числа
    case '/': return a / b;  // Если разделить - делим первое число на второе
    default: return 0;   // Если неизвестный оператор - возвращаем 0 (защита от ошибок)
    }
}

// Основная функция вычисления выражения
double gal(const string& expression) {
    stack<double> ina;    // Стек для хранения чисел из выражения
    stack<char> shu;   // Стек для хранения операторов (+, -, *, /, скобки)

    // Проходим по каждому символу в строке выражения
    for (int i = 0; i < expression.length(); i++) {
        char l = expression[i];  // Получаем текущий символ

        // Пропускаем пробелы - они не влияют на вычисления
        if (l == ' ') continue;

        // Если текущий символ - цифра (0-9)
        if (isdigit(l)) {
            double n = 0;  // Переменная для хранения числа

            // Считываем все цифры подряд чтобы получить полное число
            while (i < expression.length() && isdigit(expression[i])) {
                n = n * 10 + (expression[i] - '0');  // Умножаем на 10 и добавляем новую цифру
                i++;  // Переходим к следующему символу
            }
            i--;  // Возвращаемся на один символ назад, т.к. цикл while прошел лишний символ

            ina.push(n);  // Добавляем полученное число в стек значений
        }
        // Если открывающая скобка - просто добавляем её в стек операторов
        else if (l == '(') {
            shu.push(l);  // Скобка отмечает начало подвыражения
        }
        // Если закрывающая скобка - вычисляем всё что внутри скобок
        else if (l == ')') {
            // Выполняем операции пока не дойдем до открывающей скобки
            while (!shu.empty() && shu.top() != '(') {
                double b = ina.top(); ina.pop();  // Берем последнее число из стека (это правый операнд)
                double a = ina.top(); ina.pop();  // Берем предпоследнее число (левый операнд)
                char op = shu.top(); shu.pop();  // Берем оператор для выполнения
                ina.push(gm(a, b, op));  // Выполняем операцию и результат кладем в стекx
            }
            shu.pop();  // Удаляем открывающую скобку из стека операторов
        }
        // Если текущий символ - оператор (+, -, *, /)
        else if (l == '+' || l == '-' || l == '*' || l == '/') {
            // Проверяем на унарный минус (минус перед числом без левого операнда)
            if (l == '-' && (i == 0 || expression[i - 1] == '(' ||
                expression[i - 1] == '+' || expression[i - 1] == '-' ||
                expression[i - 1] == '*' || expression[i - 1] == '/')) {
                // Это унарный минус - обрабатываем как отрицательное число
                i++;  // Переходим к следующему символу (после минуса)

                // Проверяем, есть ли скобка после унарного минуса (например: -(5+3))
                if (expression[i] == '(') {
                    // Обрабатываем выражение в скобках
                    i++;  // Пропускаем '('
                    int a = 1;  // Счетчик скобок (уже одна открывающая)
                    string g     = "";   // Строка для подвыражения внутри скобок

                    // Извлекаем подвыражение внутри скобок
                    while (i < expression.length() && a > 0) {
                        if (expression[i] == '(') a++;  // Увеличиваем счетчик при открывающей скобке
                        if (expression[i] == ')') a--;  // Уменьшаем счетчик при закрывающей скобке
                        if (a > 0) g += expression[i];  // Добавляем символ если еще не вышли из всех скобок
                        i++;  // Переходим к следующему символу
                    }
                    i--;  // Возвращаемся на один символ назад

                    // Рекурсивно вычисляем подвыражение и делаем его отрицательным
                    double result = gal(g);  // Вычисляем выражение в скобках
                    ina.push(-result);  // Делаем результат отрицательным и кладем в стек
                }
                else {
                    // Отрицательное число без скобок (например: -5)
                    double num = 0;  // Переменная для числа
                    // Считываем число после унарного минуса
                    while (i < expression.length() && isdigit(expression[i])) {
                        num = num * 10 + (expression[i] - '0');  // Формируем число из цифр
                        i++;  // Переходим к следующей цифре
                    }
                    i--;  // Возвращаемся на один символ назад
                    ina.push(-num);  // Добавляем отрицательное число в стек
                }
            }
            else {
                // Это бинарный оператор (имеет и левый и правый операнд)
                // Выполняем операции с более высоким приоритетом перед добавлением нового оператора
                while (!shu.empty() && priory(shu.top()) >= priory(l)) {
                    double b = ina.top(); ina.pop();  // Берем правый операнд
                    double a = ina.top(); ina.pop();  // Берем левый операнд
                    char op = shu.top(); shu.pop();  // Берем оператор
                    ina.push(gm(a, b, op));  // Выполняем операцию и сохраняем результат
                }
                shu.push(l);  // Добавляем текущий оператор в стек
            }
        }
    }

    // Выполняем оставшиеся операции (когда все символы обработаны)
    while (!shu.empty()) {
        double b = ina.top(); ina.pop();  // Берем правый операнд
        double a = ina.top(); ina.pop();  // Берем левый операнд
        char op = shu.top(); shu.pop();  // Берем оператор
        ina.push(gm(a, b, op));  // Выполняем операцию и сохраняем результат
    }

    // Результат - последнее число в стеке значений (итоговый результат вычислений)
    return ina.top();
}

int main() {
    string expression;  // Переменная для хранения введенного выражения 

    // Считываем выражение из стандартного ввода (с клавиатуры или файла)
    getline(cin, expression);

    // Вычисляем результат выражения с помощью нашей функции
    double result = gal(expression);

    // Выводим результат с точностью 6 знаков после запятой
    cout << fixed << setprecision(6) << result << endl;
    // fixed - фиксированная запись чисел (не научная нотация)
    // setprecision(6) - 6 знаков после запятой

    return 0;  // Завершаем программу успешно
}